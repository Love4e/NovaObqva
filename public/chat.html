<!doctype html>
<html lang="bg">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NovaObqva — Чат</title>
  <link rel="icon" type="image/png" href="favicon.png" />
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="styles/base.css" />
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="env.js"></script>
  <style>
    .bubble{max-width:80%}
    .scroll-snap-y{scroll-snap-type:y proximity}
    .snap-start{scroll-snap-align:start}
    .hide-scrollbar::-webkit-scrollbar{display:none}
    .hide-scrollbar{scrollbar-width:none}
  </style>
</head>
<body class="bg-slate-50 min-h-screen">
  <header class="sticky top-0 z-40 bg-white/90 backdrop-blur border-b">
    <div class="max-w-6xl mx-auto px-4 py-3 flex items-center gap-3">
      <a href="/" class="flex items-center gap-2">
        <img src="favicon.png" alt="" class="w-6 h-6 rounded"/>
        <span class="text-xl font-bold">NovaObqva</span>
      </a>
      <nav class="hidden md:flex items-center gap-2 ml-4">
        <a href="index.html" class="px-3 py-1.5 rounded-lg hover:bg-slate-100">Обяви</a>
        <a href="plans.html" class="px-3 py-1.5 rounded-lg hover:bg-slate-100">Планове</a>
      </nav>
      <div class="flex-1"></div>
      <div id="nav-auth-desktop" class="hidden md:flex items-center gap-2"></div>
    </div>
  </header>

  <main class="max-w-6xl mx-auto p-4 md:p-6">
    <div class="grid md:grid-cols-[320px,1fr] gap-4">
      <aside class="bg-white rounded-2xl border overflow-hidden">
        <div class="px-4 py-3 border-b flex items-center gap-2">
          <h2 class="font-semibold">Разговори</h2>
          <input id="threadSearch" type="search" placeholder="Търси…" class="ml-auto text-sm border rounded-lg px-2 py-1.5 w-36">
        </div>
        <div id="threads" class="max-h-[70vh] overflow-auto divide-y hide-scrollbar"></div>
      </aside>

      <section class="bg-white rounded-2xl border flex flex-col min-h-[60vh]">
        <div id="chatHeader" class="px-4 py-3 border-b flex items-center gap-3">
          <div class="flex-1">
            <div id="chatTitle" class="font-semibold">Избери разговор</div>
            <div id="chatSubtitle" class="text-xs text-slate-500"></div>
          </div>
          <a id="adLink" class="hidden text-sm px-3 py-1.5 rounded-lg border hover:bg-slate-50">Към обявата</a>
        </div>

        <div id="chatLog" class="flex-1 p-3 md:p-4 overflow-auto space-y-2 scroll-snap-y bg-slate-50 hide-scrollbar"></div>

        <form id="composer" class="p-3 md:p-4 border-t flex items-end gap-2">
          <textarea id="msg" rows="1" placeholder="Напиши съобщение… (Enter=изпрати, Shift+Enter=нов ред)"
            class="flex-1 resize-none rounded-xl border px-3 py-2 focus:ring-2 focus:ring-emerald-500"></textarea>
          <button class="px-4 py-2 rounded-xl bg-emerald-600 text-white hover:bg-emerald-700">Изпрати</button>
        </form>
      </section>
    </div>
  </main>

  <script>
    const sb = supabase.createClient(ENV.SUPABASE_URL, ENV.SUPABASE_ANON_KEY);

    async function ensureAuth() {
      const { data:{ user } } = await sb.auth.getUser();
      if (!user) { location.replace('auth.html?redirectTo=' + encodeURIComponent(location.href)); await new Promise(()=>{}); }
      return user;
    }
    async function renderAuthArea(){
      const { data:{ user } } = await sb.auth.getUser();
      const d = document.getElementById('nav-auth-desktop');
      const loginHref = `auth.html?redirectTo=${encodeURIComponent(location.href)}`;
      d.classList.remove('hidden');
      d.innerHTML = user
        ? `<a href="account.html" class="px-3 py-1.5 rounded-lg border hover:bg-slate-50 text-sm">Моят профил</a>
           <button id="logout" class="px-3 py-1.5 rounded-lg bg-slate-800 text-white text-sm">Изход</button>`
        : `<a href="${loginHref}" class="px-3 py-1.5 rounded-lg bg-emerald-600 text-white text-sm">Вход</a>`;
      document.getElementById('logout')?.addEventListener('click', async ()=>{ await sb.auth.signOut(); location.href='/'; });
    }

    let me = null, currentConv = null, messagesSub = null;
    const threadsEl = document.getElementById('threads');
    const chatLogEl = document.getElementById('chatLog');
    const chatTitleEl = document.getElementById('chatTitle');
    const chatSubtitleEl = document.getElementById('chatSubtitle');
    const adLinkEl = document.getElementById('adLink');
    const msgInput = document.getElementById('msg');
    const composer = document.getElementById('composer');
    const threadSearch = document.getElementById('threadSearch');

    const esc = s => String(s||'').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
    const fmtDate = ts => new Date(ts).toLocaleString('bg-BG');
    const isUUID = v => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(v);

    function bubble(m){
      const mine = m.user_id === me.id;
      return `<div class="snap-start flex ${mine?'justify-end':''}">
        <div class="bubble rounded-2xl px-3 py-2 ${mine?'bg-emerald-600 text-white':'bg-white border'} shadow-sm">
          <div class="whitespace-pre-wrap break-words">${esc(m.content)}</div>
          <div class="mt-1 text-[11px] ${mine?'text-white/70':'text-slate-400'}">${fmtDate(m.created_at)}</div>
        </div>
      </div>`;
    }
    function threadItem(t){
      const last = t._last || {};
      const title = esc(t._ad_title || 'Разговор');
      return `<button data-conv="${t.id}" class="w-full text-left px-4 py-3 hover:bg-slate-50 ${t.id===currentConv?'bg-slate-100':''}">
        <div class="flex items-center justify-between gap-2">
          <div class="font-medium line-clamp-1">${title}</div>
          <div class="text-[11px] text-slate-500">${last.created_at?fmtDate(last.created_at):''}</div>
        </div>
        <div class="text-sm text-slate-600 line-clamp-1">${esc(last.content || '')}</div>
      </button>`;
    }

    // ------------ ВАЖНО: Зареждане на разговорите през RPC (без директен SELECT към participants)
    async function loadThreads(filter=''){
      // 1) моите разговори чрез my_conversation_ids()
      const got = await sb.rpc('my_conversation_ids');
      if (got.error) {
        console.error(got.error);
        threadsEl.innerHTML = `<div class="px-4 py-6 text-red-600">Грешка: ${got.error.message || JSON.stringify(got.error)}</div>`;
        return;
      }
      const convIds = (got.data || []).map(r => r.conversation_id);
      if (!convIds.length){
        threadsEl.innerHTML = `<div class="px-4 py-6 text-slate-500">Нямаш разговори.</div>`;
        return;
      }

      // 2) разговорите
      const { data: convs, error: convErr } = await sb
        .from('conversations')
        .select('id, ad_id, updated_at')
        .in('id', convIds)
        .order('updated_at', { ascending: false });
      if (convErr){
        console.error(convErr);
        threadsEl.innerHTML = `<div class="px-4 py-6 text-red-600">Грешка: ${convErr.message || JSON.stringify(convErr)}</div>`;
        return;
      }

      // 3) заглавия на обяви
      const adIds = [...new Set((convs||[]).map(c=>c.ad_id).filter(Boolean))];
      let adMap = {};
      if (adIds.length){
        const { data: ads, error: adsErr } = await sb.from('ads').select('id,title').in('id', adIds);
        if (adsErr){ console.error(adsErr); }
        (ads||[]).forEach(a => adMap[a.id] = a.title);
      }

      // 4) последни съобщения
      const { data: lastMsgs, error: lastErr } = await sb
        .from('messages')
        .select('conversation_id, content, created_at')
        .in('conversation_id', convIds)
        .order('created_at', { ascending:false });
      if (lastErr){ console.error(lastErr); }
      const lastMap = {};
      (lastMsgs||[]).forEach(m => { if (!lastMap[m.conversation_id]) lastMap[m.conversation_id] = m; });

      let rows = (convs||[]).map(c => ({ ...c, _ad_title: adMap[c.ad_id], _last: lastMap[c.id]}));
      if (filter){
        const f = filter.toLowerCase();
        rows = rows.filter(r => (r._ad_title||'').toLowerCase().includes(f) || (r._last?.content||'').toLowerCase().includes(f));
      }
      threadsEl.innerHTML = rows.map(threadItem).join('');
    }

    async function openConversation(convId){
      if (messagesSub){ sb.removeChannel(messagesSub); messagesSub=null; }
      currentConv = convId;

      const { data: conv } = await sb.from('conversations').select('id, ad_id, updated_at').eq('id', convId).maybeSingle();
      let adTitle = 'Разговор', adId = null;
      if (conv?.ad_id){
        const { data: ad } = await sb.from('ads').select('id,title').eq('id', conv.ad_id).maybeSingle();
        if (ad){ adTitle = ad.title; adId = ad.id; }
      }
      chatTitleEl.textContent = adTitle;
      chatSubtitleEl.textContent = conv?.updated_at ? ('Обновен: ' + fmtDate(conv.updated_at)) : '';
      if (adId){ adLinkEl.href = 'ad.html?id='+encodeURIComponent(adId); adLinkEl.classList.remove('hidden'); }
      else { adLinkEl.classList.add('hidden'); }

      const { data: msgs } = await sb
        .from('messages')
        .select('id, conversation_id, user_id, content, created_at')
        .eq('conversation_id', convId)
        .order('created_at', { ascending: true });

      chatLogEl.innerHTML = (msgs||[]).map(bubble).join('');
      chatLogEl.scrollTop = chatLogEl.scrollHeight;

      messagesSub = sb
        .channel('room:'+convId)
        .on('postgres_changes', { event:'INSERT', schema:'public', table:'messages', filter: `conversation_id=eq.${convId}` },
          payload => { chatLogEl.insertAdjacentHTML('beforeend', bubble(payload.new)); chatLogEl.scrollTop = chatLogEl.scrollHeight; loadThreads(threadSearch.value.trim()); }
        ).subscribe();

      [...threadsEl.querySelectorAll('[data-conv]')].forEach(b=>{
        b.classList.toggle('bg-slate-100', b.dataset.conv===convId);
      });
    }

    composer.addEventListener('submit', async (e)=>{
      e.preventDefault();
      const text = msgInput.value.trim();
      if (!text || !currentConv) return;
      msgInput.value=''; msgInput.style.height='auto';
      const { error } = await sb.from('messages').insert([{ conversation_id: currentConv, user_id: me.id, content: text }]);
      if (error) { console.error(error); alert('Неуспешно изпращане.'); }
    });
    msgInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); composer.requestSubmit(); }});
    msgInput.addEventListener('input', ()=>{ msgInput.style.height='auto'; msgInput.style.height = Math.min(msgInput.scrollHeight, 160) + 'px'; });

    async function maybeStartFromQuery(){
      const u = new URL(location.href);
      const convId = u.searchParams.get('id');
      const adId   = u.searchParams.get('ad');
      const toUser = u.searchParams.get('to');
      const initialMsg = (u.searchParams.get('msg')||'').trim();
      const offer      = (u.searchParams.get('offer')||'').trim();

      if (convId && isUUID(convId)){
        await openConversation(convId);
        if (initialMsg){ msgInput.value = initialMsg; msgInput.dispatchEvent(new Event('input')); }
        return;
      }

      if (adId && toUser){
        const { data, error } = await sb.rpc('ensure_conversation', { p_ad_id: adId, p_other_user: toUser });
        if (error){ console.warn(error); alert('Неуспешно създаване/намиране на чат.'); return; }

        await loadThreads(threadSearch.value.trim());
        await openConversation(data);

        let text = initialMsg;
        if (offer){
          const v = parseFloat(offer);
          const offerText = Number.isFinite(v) ? `Оферта: ${v.toFixed(2)} лв.` : `Оферта: ${offer}`;
          text = text ? `${text}\n\n${offerText}` : offerText;
        }
        if (text){ await sb.from('messages').insert([{ conversation_id: data, user_id: me.id, content: text }]); }
      }
    }

    threadsEl.addEventListener('click', async (e)=>{
      const btn = e.target.closest('[data-conv]'); if (!btn) return;
      await openConversation(btn.getAttribute('data-conv'));
    });
    threadSearch.addEventListener('input', ()=>loadThreads(threadSearch.value.trim()));

    (async ()=>{
      me = await ensureAuth();
      await renderAuthArea();
      await loadThreads();
      await maybeStartFromQuery();

      sb.channel('inbox:'+Math.random().toString(36).slice(2))
        .on('postgres_changes', { event:'INSERT', schema:'public', table:'messages' }, ()=>loadThreads(threadSearch.value.trim()))
        .subscribe();
    })();
  </script>
</body>
</html>
