<!doctype html>
<html lang="bg">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NovaObqva — Чат</title>
  <link rel="icon" type="image/png" href="favicon.png" />
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="styles/base.css" />
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="env.js"></script>
  <style>
    .bubble{max-width:80%}
    .scroll-snap-y{scroll-snap-type:y proximity}
    .snap-start{scroll-snap-align:start}
  </style>
</head>
<body class="bg-slate-50 min-h-screen">

  <!-- Header -->
  <header class="sticky top-0 z-40 bg-white/90 backdrop-blur border-b">
    <div class="max-w-6xl mx-auto px-4 py-3 flex items-center gap-3">
      <a href="/" class="flex items-center gap-2">
        <img src="favicon.png" alt="" class="w-6 h-6 rounded"/>
        <span class="text-xl font-bold">NovaObqva</span>
      </a>
      <nav class="hidden md:flex items-center gap-2 ml-4">
        <a href="index.html" class="px-3 py-1.5 rounded-lg hover:bg-slate-100">Обяви</a>
        <a href="plans.html" class="px-3 py-1.5 rounded-lg hover:bg-slate-100">Планове</a>
      </nav>
      <div class="flex-1"></div>
      <div id="nav-auth-desktop" class="hidden md:flex items-center gap-2"></div>
    </div>
  </header>

  <!-- Main -->
  <main class="max-w-6xl mx-auto p-4 md:p-6">
    <div class="grid md:grid-cols-[320px,1fr] gap-4">
      <!-- Inbox -->
      <aside class="bg-white rounded-2xl border overflow-hidden">
        <div class="px-4 py-3 border-b flex items-center gap-2">
          <h2 class="font-semibold">Разговори</h2>
          <div class="ml-auto text-xs text-slate-500">обновява се в реално време</div>
        </div>
        <div id="threads" class="max-h-[70vh] overflow-auto divide-y">
          <!-- списък -->
        </div>
      </aside>

      <!-- Chat pane -->
      <section class="bg-white rounded-2xl border flex flex-col min-h-[60vh]">
        <div id="chatHeader" class="px-4 py-3 border-b flex items-center gap-3">
          <div class="flex-1">
            <div id="chatTitle" class="font-semibold">Избери разговор</div>
            <div id="chatSubtitle" class="text-xs text-slate-500"></div>
          </div>
          <a id="adLink" class="hidden text-sm px-3 py-1.5 rounded-lg border hover:bg-slate-50">Към обявата</a>
        </div>

        <div id="chatLog" class="flex-1 p-3 md:p-4 overflow-auto space-y-2 scroll-snap-y bg-slate-50">
          <!-- съобщения -->
        </div>

        <form id="composer" class="p-3 md:p-4 border-t flex items-end gap-2">
          <textarea id="msg" rows="1" placeholder="Напиши съобщение..."
            class="flex-1 resize-none rounded-xl border px-3 py-2 focus:ring-2 focus:ring-emerald-500"></textarea>
          <button class="px-4 py-2 rounded-xl bg-emerald-600 text-white hover:bg-emerald-700">Изпрати</button>
        </form>
      </section>
    </div>
  </main>

  <script>
    // ===== Supabase client =====
    const sb = supabase.createClient(ENV.SUPABASE_URL, ENV.SUPABASE_ANON_KEY);

    // ===== Auth helpers =====
    async function ensureAuth() {
      const { data:{ user } } = await sb.auth.getUser();
      if (!user) {
        location.replace('auth.html?redirectTo=' + encodeURIComponent(location.href));
        await new Promise(()=>{});
      }
      return user;
    }
    async function renderAuthArea(){
      const { data:{ user } } = await sb.auth.getUser();
      const d = document.getElementById('nav-auth-desktop');
      const loginHref = `auth.html?redirectTo=${encodeURIComponent(location.href)}`;
      d.classList.remove('hidden');
      d.innerHTML = user
        ? `<a href="account.html" class="px-3 py-1.5 rounded-lg border hover:bg-slate-50 text-sm">Моят профил</a>
           <button id="logout" class="px-3 py-1.5 rounded-lg bg-slate-800 text-white text-sm">Изход</button>`
        : `<a href="${loginHref}" class="px-3 py-1.5 rounded-lg bg-emerald-600 text-white text-sm">Вход</a>`;
      document.getElementById('logout')?.addEventListener('click', async ()=>{ await sb.auth.signOut(); location.href='/'; });
    }

    // ===== Chat state =====
    let me = null;
    let currentConv = null;
    let messagesSub = null;     // realtime subscription for current conversation

    // DOM refs
    const threadsEl = document.getElementById('threads');
    const chatLogEl = document.getElementById('chatLog');
    const chatTitleEl = document.getElementById('chatTitle');
    const chatSubtitleEl = document.getElementById('chatSubtitle');
    const adLinkEl = document.getElementById('adLink');
    const msgInput = document.getElementById('msg');
    const composer = document.getElementById('composer');

    // ===== Utils =====
    const esc = s => String(s||'').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
    const fmtDate = ts => new Date(ts).toLocaleString('bg-BG');

    function bubble(m){
      const mine = m.user_id === me.id;
      return `
        <div class="snap-start flex ${mine?'justify-end':''}">
          <div class="bubble rounded-2xl px-3 py-2 ${mine?'bg-emerald-600 text-white':'bg-white border'}">
            <div class="whitespace-pre-wrap break-words">${esc(m.content)}</div>
            <div class="mt-1 text-[11px] ${mine?'text-white/70':'text-slate-400'}">${fmtDate(m.created_at)}</div>
          </div>
        </div>`;
    }

    function threadItem(t){
      const last = t._last || {};
      const title = esc(t._ad_title || 'Разговор');
      return `
        <button data-conv="${t.id}" class="w-full text-left px-4 py-3 hover:bg-slate-50 ${t.id===currentConv?'bg-slate-100':''}">
          <div class="flex items-center justify-between gap-2">
            <div class="font-medium line-clamp-1">${title}</div>
            <div class="text-[11px] text-slate-500">${last.created_at?fmtDate(last.created_at):''}</div>
          </div>
          <div class="text-sm text-slate-600 line-clamp-1">${esc(last.content || '')}</div>
        </button>`;
    }

    async function loadThreads(){
      // 1) моите разговори (през participants)
      const { data: parts, error } = await sb
        .from('conversation_participants')
        .select('conversation_id')
        .eq('user_id', me.id);
      if (error) { console.error(error); return; }
      const convIds = (parts||[]).map(p=>p.conversation_id);
      if (convIds.length===0){ threadsEl.innerHTML = `<div class="px-4 py-6 text-slate-500">Нямаш разговори.</div>`; return; }

      // 2) разговорите
      const { data: convs } = await sb
        .from('conversations')
        .select('id, ad_id, updated_at')
        .in('id', convIds)
        .order('updated_at', { ascending: false });

      // 3) заглавия на обяви
      const adIds = [...new Set((convs||[]).map(c=>c.ad_id).filter(Boolean))];
      let adMap = {};
      if (adIds.length){
        const { data: ads } = await sb.from('ads').select('id,title').in('id', adIds);
        (ads||[]).forEach(a => adMap[a.id] = a.title);
      }

      // 4) взимаме последно съобщение на пакет
      const { data: lastMsgs } = await sb
        .from('messages')
        .select('conversation_id, content, created_at')
        .in('conversation_id', convIds)
        .order('created_at', { ascending:false });
      const lastMap = {};
      (lastMsgs||[]).forEach(m => { if (!lastMap[m.conversation_id]) lastMap[m.conversation_id] = m; });

      const rows = (convs||[]).map(c => ({ ...c, _ad_title: adMap[c.ad_id], _last: lastMap[c.id]}));
      threadsEl.innerHTML = rows.map(threadItem).join('');
    }

    async function openConversation(convId){
      if (messagesSub){ sb.removeChannel(messagesSub); messagesSub=null; }
      currentConv = convId;

      // инфо за разговора
      const { data: conv } = await sb.from('conversations').select('id, ad_id, updated_at').eq('id', convId).maybeSingle();
      let adTitle = 'Разговор', adId = null;
      if (conv?.ad_id){
        const { data: ad } = await sb.from('ads').select('id,title').eq('id', conv.ad_id).maybeSingle();
        if (ad){ adTitle = ad.title; adId = ad.id; }
      }
      chatTitleEl.textContent = adTitle;
      chatSubtitleEl.textContent = conv?.updated_at ? ('Обновен: ' + fmtDate(conv.updated_at)) : '';
      if (adId){ adLinkEl.href = 'ad.html?id='+encodeURIComponent(adId); adLinkEl.classList.remove('hidden'); }
      else { adLinkEl.classList.add('hidden'); }

      // зареди съобщения
      const { data: msgs } = await sb
        .from('messages')
        .select('id, conversation_id, user_id, content, created_at')
        .eq('conversation_id', convId)
        .order('created_at', { ascending: true });

      chatLogEl.innerHTML = (msgs||[]).map(bubble).join('');
      chatLogEl.scrollTop = chatLogEl.scrollHeight;

      // realtime
      messagesSub = sb
        .channel('room:'+convId)
        .on('postgres_changes', {
          event: 'INSERT',
          schema: 'public',
          table: 'messages',
          filter: `conversation_id=eq.${convId}`
        }, payload => {
          chatLogEl.insertAdjacentHTML('beforeend', bubble(payload.new));
          chatLogEl.scrollTop = chatLogEl.scrollHeight;
          loadThreads();
        })
        .subscribe();

      // маркирай активния в списъка
      [...threadsEl.querySelectorAll('[data-conv]')].forEach(b=>{
        b.classList.toggle('bg-slate-100', b.dataset.conv===convId);
      });
    }

    // изпращане
    composer.addEventListener('submit', async (e)=>{
      e.preventDefault();
      const text = msgInput.value.trim();
      if (!text || !currentConv) return;
      msgInput.value=''; msgInput.style.height='auto';
      const { error } = await sb.from('messages').insert([{
        conversation_id: currentConv, user_id: me.id, content: text
      }]);
      if (error) { console.error(error); alert('Неуспешно изпращане.'); }
    });

    // авто-растеж на textarea
    msgInput.addEventListener('input', ()=>{
      msgInput.style.height='auto';
      msgInput.style.height = Math.min(msgInput.scrollHeight, 160) + 'px';
    });

    // ——— Т.3: автоматично изпращане на първо съобщение от ?msg / ?offer ———
    async function maybeSendInitial(convId, initialMsg, offerRaw){
      const key = `sent_init_${convId}_${me.id}`;
      if ((!initialMsg && !offerRaw) || sessionStorage.getItem(key)==='1') return;

      let text = (initialMsg || '').trim();
      if (offerRaw){
        const v = parseFloat(offerRaw);
        const offerText = Number.isFinite(v) ? `Оферта: ${v.toFixed(2)} лв.` : `Оферта: ${offerRaw}`;
        text = text ? `${text}\n\n${offerText}` : offerText;
      }
      if (!text) return;

      const { error } = await sb.from('messages').insert([{ conversation_id: convId, user_id: me.id, content: text }]);
      if (!error) sessionStorage.setItem(key,'1');
    }

    // отваряне от query: ?id=<conv> ИЛИ ?ad=<ad_id>&to=<user_id> (+ msg/offer по желание)
    async function maybeStartFromQuery(){
      const u = new URL(location.href);
      const convId = u.searchParams.get('id');
      const adId   = u.searchParams.get('ad');
      const toUser = u.searchParams.get('to');
      const initialMsg = (u.searchParams.get('msg')||'').trim();
      const offer      = (u.searchParams.get('offer')||'').trim();

      if (convId){
        await openConversation(convId);
        await maybeSendInitial(convId, initialMsg, offer);
        if (!sessionStorage.getItem(`sent_init_${convId}_${me.id}`) && initialMsg){
          msgInput.value = initialMsg;
          msgInput.dispatchEvent(new Event('input'));
        }
        return;
      }
      if (adId && toUser){
        const { data, error } = await sb.rpc('ensure_conversation', {
          p_ad_id: adId,
          p_other_user: toUser
        });
        if (!error && data){
          await loadThreads();
          await openConversation(data);
          await maybeSendInitial(data, initialMsg, offer);
          if (!sessionStorage.getItem(`sent_init_${data}_${me.id}`) && initialMsg){
            msgInput.value = initialMsg;
            msgInput.dispatchEvent(new Event('input'));
          }
        } else if (error){
          console.error(error);
          alert('Неуспешно отваряне на чата.');
        }
      }
    }

    // клик на нишка
    threadsEl.addEventListener('click', async (e)=>{
      const btn = e.target.closest('[data-conv]');
      if (!btn) return;
      const id = btn.getAttribute('data-conv');
      await openConversation(id);
    });

    // boot
    (async ()=>{
      me = await ensureAuth();
      await renderAuthArea();
      await loadThreads();
      await maybeStartFromQuery();

      // realtime за обновяване на inbox при нови съобщения (в която и да е нишка)
      sb.channel('inbox:'+me.id)
        .on('postgres_changes', { event:'INSERT', schema:'public', table:'messages' }, payload=>{
          loadThreads();
        })
        .subscribe();
    })();
  </script>
</body>
</html>
