<!doctype html>
<html lang="bg">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NovaObqva — Чат (нов)</title>
  <link rel="icon" type="image/png" href="favicon.png" />
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="styles/base.css" />
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="env.js"></script>
  <style>
    .bubble{max-width:80%}
    .scroll-snap-y{scroll-snap-type:y proximity}
    .snap-start{scroll-snap-align:start}
    .hide-scrollbar::-webkit-scrollbar{display:none}
    .hide-scrollbar{scrollbar-width:none}
  </style>
</head>
<body class="bg-slate-50 min-h-screen">

  <!-- Header -->
  <header class="sticky top-0 z-40 bg-white/90 backdrop-blur border-b">
    <div class="max-w-6xl mx-auto px-4 py-3 flex items-center gap-3">
      <a href="/" class="flex items-center gap-2">
        <img src="favicon.png" alt="" class="w-6 h-6 rounded"/>
        <span class="text-xl font-bold">NovaObqva</span>
      </a>
      <nav class="hidden md:flex items-center gap-2 ml-4">
        <a href="index.html" class="px-3 py-1.5 rounded-lg hover:bg-slate-100">Обяви</a>
        <a href="plans.html" class="px-3 py-1.5 rounded-lg hover:bg-slate-100">Планове</a>
      </nav>
      <div class="flex-1"></div>
      <div id="nav-auth-desktop" class="hidden md:flex items-center gap-2"></div>
    </div>
  </header>

  <!-- Main -->
  <main class="max-w-6xl mx-auto p-4 md:p-6">
    <div class="grid md:grid-cols-[320px,1fr] gap-4">

      <!-- Inbox -->
      <aside class="bg-white rounded-2xl border overflow-hidden">
        <div class="px-4 py-3 border-b flex items-center gap-2">
          <h2 class="font-semibold">Разговори</h2>
          <input id="threadSearch" type="search" placeholder="Търси…" class="ml-auto text-sm border rounded-lg px-2 py-1.5 w-36">
        </div>
        <div id="threads" class="max-h-[70vh] overflow-auto divide-y hide-scrollbar"></div>
      </aside>

      <!-- Chat pane -->
      <section class="bg-white rounded-2xl border flex flex-col min-h-[60vh]">
        <div id="chatHeader" class="px-4 py-3 border-b flex items-center gap-3">
          <div class="flex-1">
            <div id="chatTitle" class="font-semibold">Избери разговор</div>
            <div id="chatSubtitle" class="text-xs text-slate-500"></div>
          </div>
          <a id="adLink" class="hidden text-sm px-3 py-1.5 rounded-lg border hover:bg-slate-50">Към обявата</a>
        </div>

        <div id="chatLog" class="flex-1 p-3 md:p-4 overflow-auto space-y-2 scroll-snap-y bg-slate-50 hide-scrollbar"></div>

        <form id="composer" class="p-3 md:p-4 border-t flex items-end gap-2">
          <textarea id="msg" rows="1" placeholder="Напиши съобщение… (Enter=изпрати, Shift+Enter=нов ред)"
            class="flex-1 resize-none rounded-xl border px-3 py-2 focus:ring-2 focus:ring-emerald-500"></textarea>
          <button class="px-4 py-2 rounded-xl bg-emerald-600 text-white hover:bg-emerald-700">Изпрати</button>
        </form>
      </section>
    </div>
  </main>

  <script>
    // =============== Supabase client ===============
    const sb = supabase.createClient(ENV.SUPABASE_URL, ENV.SUPABASE_ANON_KEY);

    // =============== Auth ===============
    async function ensureAuth() {
      const { data:{ user } } = await sb.auth.getUser();
      if (!user) { location.replace('auth.html?redirectTo=' + encodeURIComponent(location.href)); await new Promise(()=>{}); }
      return user;
    }
    async function renderAuthArea(){
      const { data:{ user } } = await sb.auth.getUser();
      const d = document.getElementById('nav-auth-desktop');
      const loginHref = `auth.html?redirectTo=${encodeURIComponent(location.href)}`;
      d.classList.remove('hidden');
      d.innerHTML = user
        ? `<a href="account.html" class="px-3 py-1.5 rounded-lg border hover:bg-slate-50 text-sm">Моят профил</a>
           <button id="logout" class="px-3 py-1.5 rounded-lg bg-slate-800 text-white text-sm">Изход</button>`
        : `<a href="${loginHref}" class="px-3 py-1.5 rounded-lg bg-emerald-600 text-white text-sm">Вход</a>`;
      document.getElementById('logout')?.addEventListener('click', async ()=>{ await sb.auth.signOut(); location.href='/'; });
    }

    // =============== State & Refs ===============
    let me = null;
    let currentConv = null;
    let messagesSub = null;

    const threadsEl = document.getElementById('threads');
    const chatLogEl = document.getElementById('chatLog');
    const chatTitleEl = document.getElementById('chatTitle');
    const chatSubtitleEl = document.getElementById('chatSubtitle');
    const adLinkEl = document.getElementById('adLink');
    const msgInput = document.getElementById('msg');
    const composer = document.getElementById('composer');
    const threadSearch = document.getElementById('threadSearch');

    // =============== Utils ===============
    const esc = s => String(s||'').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
    const fmtDate = ts => new Date(ts).toLocaleString('bg-BG');
    const isUUID = v => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(v);

    function bubble(m){
      const mine = m.user_id === me.id;
      return `
        <div class="snap-start flex ${mine?'justify-end':''}">
          <div class="bubble rounded-2xl px-3 py-2 ${mine?'bg-emerald-600 text-white':'bg-white border'} shadow-sm">
            <div class="whitespace-pre-wrap break-words">${esc(m.content)}</div>
            <div class="mt-1 text-[11px] ${mine?'text-white/70':'text-slate-400'}">${fmtDate(m.created_at)}</div>
          </div>
        </div>`;
    }

    function threadItem(t){
      const last = t._last || {};
      const title = esc(t._ad_title || 'Разговор');
      return `
        <button data-conv="${t.id}" class="w-full text-left px-4 py-3 hover:bg-slate-50 ${t.id===currentConv?'bg-slate-100':''}">
          <div class="flex items-center justify-between gap-2">
            <div class="font-medium line-clamp-1">${title}</div>
            <div class="text-[11px] text-slate-500">${last.created_at?fmtDate(last.created_at):''}</div>
          </div>
          <div class="text-sm text-slate-600 line-clamp-1">${esc(last.content || '')}</div>
        </button>`;
    }

    // =============== Data loading ===============
    async function loadThreads(filter=''){
      const { data: parts, error } = await sb
        .from('conversation_participants')
        .select('conversation_id')
        .eq('user_id', me.id);
      if (error) { console.error(error); return; }
      const convIds = (parts||[]).map(p=>p.conversation_id);
      if (!convIds.length){
        threadsEl.innerHTML = `<div class="px-4 py-6 text-slate-500">Нямаш разговори.</div>`;
        return;
      }

      const { data: convs, error: convErr } = await sb
        .from('conversations')
        .select('id, ad_id, updated_at')
        .in('id', convIds)
        .order('updated_at', { ascending: false });
      if (convErr){ console.error(convErr); return; }

      const adIds = [...new Set((convs||[]).map(c=>c.ad_id).filter(Boolean))];
      let adMap = {};
      if (adIds.length){
        const { data: ads } = await sb.from('ads').select('id,title').in('id', adIds);
        (ads||[]).forEach(a => adMap[a.id] = a.title);
      }

      const { data: lastMsgs } = await sb
        .from('messages')
        .select('conversation_id, content, created_at')
        .in('conversation_id', convIds)
        .order('created_at', { ascending:false });
      const lastMap = {};
      (lastMsgs||[]).forEach(m => { if (!lastMap[m.conversation_id]) lastMap[m.conversation_id] = m; });

      let rows = (convs||[]).map(c => ({ ...c, _ad_title: adMap[c.ad_id], _last: lastMap[c.id]}));

      if (filter){
        const f = filter.toLowerCase();
        rows = rows.filter(r => (r._ad_title||'').toLowerCase().includes(f) || (r._last?.content||'').toLowerCase().includes(f));
      }

      threadsEl.innerHTML = rows.map(threadItem).join('');
    }

    async function openConversation(convId){
      if (messagesSub){ sb.removeChannel(messagesSub); messagesSub=null; }
      currentConv = convId;

      const { data: conv } = await sb.from('conversations').select('id, ad_id, updated_at').eq('id', convId).maybeSingle();

      let adTitle = 'Разговор', adId = null;
      if (conv?.ad_id){
        const { data: ad } = await sb.from('ads').select('id,title').eq('id', conv.ad_id).maybeSingle();
        if (ad){ adTitle = ad.title; adId = ad.id; }
      }
      chatTitleEl.textContent = adTitle;
      chatSubtitleEl.textContent = conv?.updated_at ? ('Обновен: ' + fmtDate(conv.updated_at)) : '';
      if (adId){ adLinkEl.href = 'ad.html?id='+encodeURIComponent(adId); adLinkEl.classList.remove('hidden'); }
      else { adLinkEl.classList.add('hidden'); }

      const { data: msgs } = await sb
        .from('messages')
        .select('id, conversation_id, user_id, content, created_at')
        .eq('conversation_id', convId)
        .order('created_at', { ascending: true });

      chatLogEl.innerHTML = (msgs||[]).map(bubble).join('');
      chatLogEl.scrollTop = chatLogEl.scrollHeight;

      messagesSub = sb
        .channel('room:'+convId)
        .on('postgres_changes', {
          event: 'INSERT',
          schema: 'public',
          table: 'messages',
          filter: `conversation_id=eq.${convId}`
        }, payload => {
          chatLogEl.insertAdjacentHTML('beforeend', bubble(payload.new));
          if (chatLogEl.scrollHeight - chatLogEl.scrollTop - chatLogEl.clientHeight < 120){
            chatLogEl.scrollTop = chatLogEl.scrollHeight;
          }
          loadThreads(threadSearch.value.trim());
        })
        .subscribe();

      [...threadsEl.querySelectorAll('[data-conv]')].forEach(b=>{
        b.classList.toggle('bg-slate-100', b.dataset.conv===convId);
      });
    }

    // =============== Composer ===============
    composer.addEventListener('submit', async (e)=>{
      e.preventDefault();
      const text = msgInput.value.trim();
      if (!text || !currentConv) return;
      msgInput.value=''; msgInput.style.height='auto';
      const { error } = await sb.from('messages').insert([{ conversation_id: currentConv, user_id: me.id, content: text }]);
      if (error) { console.error(error); alert('Неуспешно изпращане.'); }
    });
    msgInput.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter' && !e.shiftKey){
        e.preventDefault();
        composer.requestSubmit();
      }
    });
    msgInput.addEventListener('input', ()=>{
      msgInput.style.height='auto';
      msgInput.style.height = Math.min(msgInput.scrollHeight, 160) + 'px';
    });

    // ===== helper: гарантира, че даден user е участник (required=true за мен; false за другия) =====
    async function ensureParticipant(convId, userId, required=false){
      const { data: exists } = await sb
        .from('conversation_participants')
        .select('conversation_id')
        .eq('conversation_id', convId)
        .eq('user_id', userId)
        .maybeSingle();
      if (exists) return true;

      const { error } = await sb
        .from('conversation_participants')
        .insert([{ conversation_id: convId, user_id: userId }]);
      if (error){
        console.warn('ensureParticipant error', { convId, userId, error });
        if (required) throw error; // за мен е задължително
        return false;
      }
      return true;
    }

    // =============== New conversation (client-side, без RPC) ===============
    async function ensureConversationClient(adId, otherUserId) {
      if (!isUUID(adId) || !isUUID(otherUserId)) throw new Error('Невалиден UUID параметър.');

      // 1) Потърси всички разговори за тази обява
      const { data: convs, error: cErr } = await sb
        .from('conversations')
        .select('id')
        .eq('ad_id', adId);
      if (cErr) throw cErr;

      if (convs?.length){
        const ids = convs.map(c=>c.id);

        // 1.1) Зареди участниците за тези разговори
        const { data: parts, error: pErr } = await sb
          .from('conversation_participants')
          .select('conversation_id, user_id')
          .in('conversation_id', ids);
        if (pErr) throw pErr;

        const byConv = new Map();
        (parts||[]).forEach(p=>{
          if(!byConv.has(p.conversation_id)) byConv.set(p.conversation_id, new Set());
          byConv.get(p.conversation_id).add(p.user_id);
        });

        // a) ако има нишка с двамата → върни я
        for (const id of ids){
          const set = byConv.get(id) || new Set();
          if (set.has(me.id) && set.has(otherUserId)) return id;
        }
        // b) ако има нишка с другия, но без теб → добави теб и върни
        for (const id of ids){
          const set = byConv.get(id) || new Set();
          if (set.has(otherUserId) && !set.has(me.id)){
            await ensureParticipant(id, me.id, true);
            return id;
          }
        }
        // c) ако има нишка с теб, но без другия → опитай да добавиш другия и върни
        for (const id of ids){
          const set = byConv.get(id) || new Set();
          if (set.has(me.id) && !set.has(otherUserId)){
            await ensureParticipant(id, otherUserId, false); // опит, но не блокира
            return id;
          }
        }
      }

      // 2) Няма подходяща нишка → създай нова
      const { data: created, error: createErr } = await sb
        .from('conversations')
        .insert([{ ad_id: adId }])
        .select('id')
        .single();
      if (createErr) throw createErr;

      const convId = created.id;

      // 3) Добави участниците поотделно (мен – задължително; другия – best effort)
      await ensureParticipant(convId, me.id, true);
      await ensureParticipant(convId, otherUserId, false);

      return convId;
    }

    // =============== URL open: ?id=... | ?ad=...&to=... (+ optional msg/offer) ===============
    async function maybeStartFromQuery(){
      const u = new URL(location.href);
      const convId = u.searchParams.get('id');
      const adId   = u.searchParams.get('ad');
      const toUser = u.searchParams.get('to');
      const initialMsg = (u.searchParams.get('msg')||'').trim();
      const offer      = (u.searchParams.get('offer')||'').trim();

      if (convId && isUUID(convId)){
        await openConversation(convId);
        if (initialMsg) { msgInput.value = initialMsg; msgInput.dispatchEvent(new Event('input')); }
        return;
      }

      if (adId && toUser){
        try{
          const conv = await ensureConversationClient(adId, toUser);
          await loadThreads(threadSearch.value.trim());
          await openConversation(conv);

          // авто първо съобщение
          let text = initialMsg;
          if (offer){
            const v = parseFloat(offer);
            const offerText = Number.isFinite(v) ? `Оферта: ${v.toFixed(2)} лв.` : `Оферта: ${offer}`;
            text = text ? `${text}\n\n${offerText}` : offerText;
          }
          if (text){
            await sb.from('messages').insert([{ conversation_id: conv, user_id: me.id, content: text }]);
          }
        } catch(e){
          console.error(e);
          alert('Неуспешно отваряне на чата.');
        }
      }
    }

    // =============== Events ===============
    threadsEl.addEventListener('click', async (e)=>{
      const btn = e.target.closest('[data-conv]');
      if (!btn) return;
      await openConversation(btn.getAttribute('data-conv'));
    });
    threadSearch.addEventListener('input', ()=>loadThreads(threadSearch.value.trim()));

    // =============== Boot ===============
    (async ()=>{
      me = await ensureAuth();
      await renderAuthArea();
      await loadThreads();
      await maybeStartFromQuery();

      // realtime обновяване на inbox при нови съобщения
      sb.channel('inbox:'+Math.random().toString(36).slice(2))
        .on('postgres_changes', { event:'INSERT', schema:'public', table:'messages' }, ()=>loadThreads(threadSearch.value.trim()))
        .subscribe();
    })();
  </script>
</body>
</html>
